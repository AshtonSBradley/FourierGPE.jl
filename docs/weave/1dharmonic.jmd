---
title: Solve the GPE in a 1D parabolic trap
author: Ashton Bradley
---

# Introduction
In this simple example we find a ground state of the Gross-Pitaevskii equation
in a harmonic trap.

The mean field order parameter evolves according to
$$
i\hbar\frac{\partial \psi(x,t)}{\partial t}=\left(-\frac{\hbar^2\partial_x^2}{2m}+V(x,t)+g|\psi(x,t)|^2\right)\psi(x,t)
$$

# Loading the package
First, we load some useful packages.
```julia
using Plots, LaTeXStrings, Pkg, Revise
gr(legend=false,titlefontsize=12,size=(500,300),transpose=true,colorbar=false);
```
Now load `FourierGPE`
```julia
using FourierGPE
```
Let's define a convenient plot function
```julia
function showpsi(x,ψ)
    p1 = plot(x,abs2.(ψ))
    xlabel!(L"x/a_x");ylabel!(L"|\psi|^2")
    p2 = plot(x,angle.(ψ))
    xlabel!(L"x/a_x");ylabel!(L"\textrm{phase}(\psi)")
    p = plot(p1,p2,layout=(2,1),size=(600,400))
    return p
end
```

# User parameters
We reserve a place for user parameters.
```julia
@with_kw mutable struct Params <: UserParams @deftype Float64
    # user parameters:
    κ = 0.1
end
par = Params();
```

Let's set the system size, and number of spatial points
```julia
L = (20.0,)
N = (128,)
X,K,dX,dK,DX,DK,T = maketransforms(L,N)
espec = 0.5*k2(L...,N...);
```
Now we need to initialize the simulation object and the transforms
```julia
sim = Sim(L,N,par)
@pack! sim = T,X,K,espec
initsim!(sim)
@unpack_Sim sim;
```
## Declaring the potential
Let's define the trapping potential.
```julia
import FourierGPE.V
V(x,t) = 0.5*x^2
```
We only require that it is a scalar function
because alter we will evaluate it using a broadcasted dot-call.

# Initial condition
Let's define a useful Thomas-Fermi wavefunction
```julia
ψ0(x,μ,g) = sqrt(μ/g)*sqrt(max(1.0-V(x,0.0)/μ,0.0)+im*0.0)
x = X[1];
```
The initial state is now created as
```julia
ψi = ψ0.(x,μ,g)
ψi .+= (randn(N...) |> complex)
ϕi = kspace(ψi,sim)
@pack! sim = ϕi;
```

# Evolution in k-space
The `FFTW` library is used to evolve the Gross-Pitaevskii equation in k-space
```julia
sol = runsim(sim.ϕi,sim);
```
Here we save the entire solution as a single variable `sol`.

Let's have a look at the final state and verify we have a ground state
```julia
ϕg = sol[end]
ψg = xspace(ϕg,sim)
showpsi(x,ψg)
```
The initial Thomas-Fermi state has been evolved for a default time $t=2/\gamma$ which is
a characteristic damping time for the dissipative system with dimensionless damping
$\gamma$. The solution will approch the ground state satisfying $L\psi_0=\mu\psi_0$ on a timescale of order
$1/\gamma$. The figure shows a smooth density profile and a completely homogeneous phase
profile over the region of finite atomic density, as required for the ground state. The indeterminate
phase evident at large $|x|$ is unimportant.

## Default simulation parameters
The default parameters are given in the declaration of `Sim`, which allows parameter interdependence.
The struct `Sim` is declared as:

```julia; eval = false
@with_kw mutable struct Sim{D} <: Simulation{D} @deftype Float64
    L::NTuple{D,Float64}
    N::NTuple{D,Int64}
    μ = 15.0
    g = 0.1
    γ = 0.5; @assert γ >= 0.0
    ti = 0.0
    tf = 2/γ
    Nt::Int64 = 200
    t::LinRange{Float64} = LinRange(ti,tf,Nt)
    ϕi::Array{Complex{Float64},D} = zeros(N...) |> complex
    params::UserParams # optional parameters
    X::NTuple{D,Array{Float64,1}} = xvecs(L...,N...)
    K::NTuple{D,Array{Float64,1}} = kvecs(L...,N...)
    espec::Array{Complex{Float64},D} = k2(L...,N...)
    T::TransformLibrary{D} = Transforms{D}()
end
```
where we see a set of default parameters, and then some useful transform fields built using the parameters.
Note that the transforms have to be built after building `X,K`.

# Dark soliton in harmonically trapped system
We found a ground state by imaginary time propagation.
Now we can impose a phase and density imprint consistent with a dark soliton.
We will use the solution for the homogeneous system, which will be a reasonable
approximation if we impose it on a smooth background solution.

## Imprinting a dark soliton
```julia
ψf = sol[end]
c = sqrt(μ)
ξ = 1/sqrt(g*abs2.(ψf[Int(end/2)]))
v = 0.3*c;
```
Soliton speed is determined by depth and local healing length. Start at $xs=0.0$
```julia
xs = 0.
v = 0.5*c
f = sqrt(1-(v/c)^2)

ψs = @. ψf*(f*tanh(f*(x -xs)/ξ)+im*v/c);
```
## Initilize Simulation
We can recycle our earlier parameter choices, modifying the damping and simulation timescale
```julia
γ = 0.0
tf = 8*pi/sqrt(2); t = LinRange(ti,tf,Nt)
simSoliton = Sim(sim;γ=γ,tf=tf,t=t)
# @pack! simSoliton = T
initsim!(simSoliton)
@unpack_Sim simSoliton;
```
In doing so, we have to specify the dimension of the simulation in this case (an improved constructor needed).

## Solve equation of motion
As before, we specify the initial condition in momentum space, and evolve
```julia
ϕi = kspace(ψs,simSoliton)
@pack! simSoliton = ϕi;
sols = runsim(simSoliton.ϕi,simSoliton);
```

## View the solution using Plots
```julia
y = g*abs2.(sols[Nt-4])
plot(x,y,fill=(y,0.4),size=(400,200),legend=false,grid=false)
xlims!(-10,10);ylims!(0,1.2*μ)
xlabel!(L"x/a_x")
ylabel!(L"\mu(x)/\hbar\omega_x")
title!(L"\textrm{local}\;\mu",titlefontsize=12)
```
